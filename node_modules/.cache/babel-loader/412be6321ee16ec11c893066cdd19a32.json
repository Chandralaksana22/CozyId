{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.symbol.iterator.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.object.keys.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.json.stringify.js\");\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SubscriptionClient = void 0;\n\nvar _global = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : {};\n\nvar NativeWebSocket = _global.WebSocket || _global.MozWebSocket;\n\nvar Backoff = require(\"backo2\");\n\nvar eventemitter3_1 = require(\"eventemitter3\");\n\nvar is_string_1 = require(\"./utils/is-string\");\n\nvar is_object_1 = require(\"./utils/is-object\");\n\nvar printer_1 = require(\"graphql/language/printer\");\n\nvar getOperationAST_1 = require(\"graphql/utilities/getOperationAST\");\n\nvar symbol_observable_1 = require(\"symbol-observable\");\n\nvar protocol_1 = require(\"./protocol\");\n\nvar defaults_1 = require(\"./defaults\");\n\nvar message_types_1 = require(\"./message-types\");\n\nvar SubscriptionClient = function () {\n  function SubscriptionClient(url, options, webSocketImpl, webSocketProtocols) {\n    var _a = options || {},\n        _b = _a.connectionCallback,\n        connectionCallback = _b === void 0 ? undefined : _b,\n        _c = _a.connectionParams,\n        connectionParams = _c === void 0 ? {} : _c,\n        _d = _a.minTimeout,\n        minTimeout = _d === void 0 ? defaults_1.MIN_WS_TIMEOUT : _d,\n        _e = _a.timeout,\n        timeout = _e === void 0 ? defaults_1.WS_TIMEOUT : _e,\n        _f = _a.reconnect,\n        reconnect = _f === void 0 ? false : _f,\n        _g = _a.reconnectionAttempts,\n        reconnectionAttempts = _g === void 0 ? Infinity : _g,\n        _h = _a.lazy,\n        lazy = _h === void 0 ? false : _h,\n        _j = _a.inactivityTimeout,\n        inactivityTimeout = _j === void 0 ? 0 : _j,\n        _k = _a.wsOptionArguments,\n        wsOptionArguments = _k === void 0 ? [] : _k;\n\n    this.wsImpl = webSocketImpl || NativeWebSocket;\n\n    if (!this.wsImpl) {\n      throw new Error('Unable to find native implementation, or alternative implementation for WebSocket!');\n    }\n\n    this.wsProtocols = webSocketProtocols || protocol_1.GRAPHQL_WS;\n    this.connectionCallback = connectionCallback;\n    this.url = url;\n    this.operations = {};\n    this.nextOperationId = 0;\n    this.minWsTimeout = minTimeout;\n    this.wsTimeout = timeout;\n    this.unsentMessagesQueue = [];\n    this.reconnect = reconnect;\n    this.reconnecting = false;\n    this.reconnectionAttempts = reconnectionAttempts;\n    this.lazy = !!lazy;\n    this.inactivityTimeout = inactivityTimeout;\n    this.closedByUser = false;\n    this.backoff = new Backoff({\n      jitter: 0.5\n    });\n    this.eventEmitter = new eventemitter3_1.EventEmitter();\n    this.middlewares = [];\n    this.client = null;\n    this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();\n    this.connectionParams = this.getConnectionParams(connectionParams);\n    this.wsOptionArguments = wsOptionArguments;\n\n    if (!this.lazy) {\n      this.connect();\n    }\n  }\n\n  Object.defineProperty(SubscriptionClient.prototype, \"status\", {\n    get: function get() {\n      if (this.client === null) {\n        return this.wsImpl.CLOSED;\n      }\n\n      return this.client.readyState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  SubscriptionClient.prototype.close = function (isForced, closedByUser) {\n    if (isForced === void 0) {\n      isForced = true;\n    }\n\n    if (closedByUser === void 0) {\n      closedByUser = true;\n    }\n\n    this.clearInactivityTimeout();\n\n    if (this.client !== null) {\n      this.closedByUser = closedByUser;\n\n      if (isForced) {\n        this.clearCheckConnectionInterval();\n        this.clearMaxConnectTimeout();\n        this.clearTryReconnectTimeout();\n        this.unsubscribeAll();\n        this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_TERMINATE, null);\n      }\n\n      this.client.close();\n      this.client.onopen = null;\n      this.client.onclose = null;\n      this.client.onerror = null;\n      this.client.onmessage = null;\n      this.client = null;\n      this.eventEmitter.emit('disconnected');\n\n      if (!isForced) {\n        this.tryReconnect();\n      }\n    }\n  };\n\n  SubscriptionClient.prototype.request = function (request) {\n    var _a;\n\n    var getObserver = this.getObserver.bind(this);\n    var executeOperation = this.executeOperation.bind(this);\n\n    var _unsubscribe = this.unsubscribe.bind(this);\n\n    var opId;\n    this.clearInactivityTimeout();\n    return _a = {}, _a[symbol_observable_1.default] = function () {\n      return this;\n    }, _a.subscribe = function (observerOrNext, onError, onComplete) {\n      var observer = getObserver(observerOrNext, onError, onComplete);\n      opId = executeOperation(request, function (error, result) {\n        if (error === null && result === null) {\n          if (observer.complete) {\n            observer.complete();\n          }\n        } else if (error) {\n          if (observer.error) {\n            observer.error(error[0]);\n          }\n        } else {\n          if (observer.next) {\n            observer.next(result);\n          }\n        }\n      });\n      return {\n        unsubscribe: function unsubscribe() {\n          if (opId) {\n            _unsubscribe(opId);\n\n            opId = null;\n          }\n        }\n      };\n    }, _a;\n  };\n\n  SubscriptionClient.prototype.on = function (eventName, callback, context) {\n    var handler = this.eventEmitter.on(eventName, callback, context);\n    return function () {\n      handler.off(eventName, callback, context);\n    };\n  };\n\n  SubscriptionClient.prototype.onConnected = function (callback, context) {\n    return this.on('connected', callback, context);\n  };\n\n  SubscriptionClient.prototype.onConnecting = function (callback, context) {\n    return this.on('connecting', callback, context);\n  };\n\n  SubscriptionClient.prototype.onDisconnected = function (callback, context) {\n    return this.on('disconnected', callback, context);\n  };\n\n  SubscriptionClient.prototype.onReconnected = function (callback, context) {\n    return this.on('reconnected', callback, context);\n  };\n\n  SubscriptionClient.prototype.onReconnecting = function (callback, context) {\n    return this.on('reconnecting', callback, context);\n  };\n\n  SubscriptionClient.prototype.onError = function (callback, context) {\n    return this.on('error', callback, context);\n  };\n\n  SubscriptionClient.prototype.unsubscribeAll = function () {\n    var _this = this;\n\n    Object.keys(this.operations).forEach(function (subId) {\n      _this.unsubscribe(subId);\n    });\n  };\n\n  SubscriptionClient.prototype.applyMiddlewares = function (options) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var queue = function queue(funcs, scope) {\n        var next = function next(error) {\n          if (error) {\n            reject(error);\n          } else {\n            if (funcs.length > 0) {\n              var f = funcs.shift();\n\n              if (f) {\n                f.applyMiddleware.apply(scope, [options, next]);\n              }\n            } else {\n              resolve(options);\n            }\n          }\n        };\n\n        next();\n      };\n\n      queue(__spreadArrays(_this.middlewares), _this);\n    });\n  };\n\n  SubscriptionClient.prototype.use = function (middlewares) {\n    var _this = this;\n\n    middlewares.map(function (middleware) {\n      if (typeof middleware.applyMiddleware === 'function') {\n        _this.middlewares.push(middleware);\n      } else {\n        throw new Error('Middleware must implement the applyMiddleware function.');\n      }\n    });\n    return this;\n  };\n\n  SubscriptionClient.prototype.getConnectionParams = function (connectionParams) {\n    return function () {\n      return new Promise(function (resolve, reject) {\n        if (typeof connectionParams === 'function') {\n          try {\n            return resolve(connectionParams.call(null));\n          } catch (error) {\n            return reject(error);\n          }\n        }\n\n        resolve(connectionParams);\n      });\n    };\n  };\n\n  SubscriptionClient.prototype.executeOperation = function (options, handler) {\n    var _this = this;\n\n    if (this.client === null) {\n      this.connect();\n    }\n\n    var opId = this.generateOperationId();\n    this.operations[opId] = {\n      options: options,\n      handler: handler\n    };\n    this.applyMiddlewares(options).then(function (processedOptions) {\n      _this.checkOperationOptions(processedOptions, handler);\n\n      if (_this.operations[opId]) {\n        _this.operations[opId] = {\n          options: processedOptions,\n          handler: handler\n        };\n\n        _this.sendMessage(opId, message_types_1.default.GQL_START, processedOptions);\n      }\n    }).catch(function (error) {\n      _this.unsubscribe(opId);\n\n      handler(_this.formatErrors(error));\n    });\n    return opId;\n  };\n\n  SubscriptionClient.prototype.getObserver = function (observerOrNext, _error, _complete) {\n    if (typeof observerOrNext === 'function') {\n      return {\n        next: function next(v) {\n          return observerOrNext(v);\n        },\n        error: function error(e) {\n          return _error && _error(e);\n        },\n        complete: function complete() {\n          return _complete && _complete();\n        }\n      };\n    }\n\n    return observerOrNext;\n  };\n\n  SubscriptionClient.prototype.createMaxConnectTimeGenerator = function () {\n    var minValue = this.minWsTimeout;\n    var maxValue = this.wsTimeout;\n    return new Backoff({\n      min: minValue,\n      max: maxValue,\n      factor: 1.2\n    });\n  };\n\n  SubscriptionClient.prototype.clearCheckConnectionInterval = function () {\n    if (this.checkConnectionIntervalId) {\n      clearInterval(this.checkConnectionIntervalId);\n      this.checkConnectionIntervalId = null;\n    }\n  };\n\n  SubscriptionClient.prototype.clearMaxConnectTimeout = function () {\n    if (this.maxConnectTimeoutId) {\n      clearTimeout(this.maxConnectTimeoutId);\n      this.maxConnectTimeoutId = null;\n    }\n  };\n\n  SubscriptionClient.prototype.clearTryReconnectTimeout = function () {\n    if (this.tryReconnectTimeoutId) {\n      clearTimeout(this.tryReconnectTimeoutId);\n      this.tryReconnectTimeoutId = null;\n    }\n  };\n\n  SubscriptionClient.prototype.clearInactivityTimeout = function () {\n    if (this.inactivityTimeoutId) {\n      clearTimeout(this.inactivityTimeoutId);\n      this.inactivityTimeoutId = null;\n    }\n  };\n\n  SubscriptionClient.prototype.setInactivityTimeout = function () {\n    var _this = this;\n\n    if (this.inactivityTimeout > 0 && Object.keys(this.operations).length === 0) {\n      this.inactivityTimeoutId = setTimeout(function () {\n        if (Object.keys(_this.operations).length === 0) {\n          _this.close();\n        }\n      }, this.inactivityTimeout);\n    }\n  };\n\n  SubscriptionClient.prototype.checkOperationOptions = function (options, handler) {\n    var query = options.query,\n        variables = options.variables,\n        operationName = options.operationName;\n\n    if (!query) {\n      throw new Error('Must provide a query.');\n    }\n\n    if (!handler) {\n      throw new Error('Must provide an handler.');\n    }\n\n    if (!is_string_1.default(query) && !getOperationAST_1.getOperationAST(query, operationName) || operationName && !is_string_1.default(operationName) || variables && !is_object_1.default(variables)) {\n      throw new Error('Incorrect option types. query must be a string or a document,' + '`operationName` must be a string, and `variables` must be an object.');\n    }\n  };\n\n  SubscriptionClient.prototype.buildMessage = function (id, type, payload) {\n    var payloadToReturn = payload && payload.query ? __assign(__assign({}, payload), {\n      query: typeof payload.query === 'string' ? payload.query : printer_1.print(payload.query)\n    }) : payload;\n    return {\n      id: id,\n      type: type,\n      payload: payloadToReturn\n    };\n  };\n\n  SubscriptionClient.prototype.formatErrors = function (errors) {\n    if (Array.isArray(errors)) {\n      return errors;\n    }\n\n    if (errors && errors.errors) {\n      return this.formatErrors(errors.errors);\n    }\n\n    if (errors && errors.message) {\n      return [errors];\n    }\n\n    return [{\n      name: 'FormatedError',\n      message: 'Unknown error',\n      originalError: errors\n    }];\n  };\n\n  SubscriptionClient.prototype.sendMessage = function (id, type, payload) {\n    this.sendMessageRaw(this.buildMessage(id, type, payload));\n  };\n\n  SubscriptionClient.prototype.sendMessageRaw = function (message) {\n    switch (this.status) {\n      case this.wsImpl.OPEN:\n        var serializedMessage = JSON.stringify(message);\n\n        try {\n          JSON.parse(serializedMessage);\n        } catch (e) {\n          this.eventEmitter.emit('error', new Error(\"Message must be JSON-serializable. Got: \" + message));\n        }\n\n        this.client.send(serializedMessage);\n        break;\n\n      case this.wsImpl.CONNECTING:\n        this.unsentMessagesQueue.push(message);\n        break;\n\n      default:\n        if (!this.reconnecting) {\n          this.eventEmitter.emit('error', new Error('A message was not sent because socket is not connected, is closing or ' + 'is already closed. Message was: ' + JSON.stringify(message)));\n        }\n\n    }\n  };\n\n  SubscriptionClient.prototype.generateOperationId = function () {\n    return String(++this.nextOperationId);\n  };\n\n  SubscriptionClient.prototype.tryReconnect = function () {\n    var _this = this;\n\n    if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {\n      return;\n    }\n\n    if (!this.reconnecting) {\n      Object.keys(this.operations).forEach(function (key) {\n        _this.unsentMessagesQueue.push(_this.buildMessage(key, message_types_1.default.GQL_START, _this.operations[key].options));\n      });\n      this.reconnecting = true;\n    }\n\n    this.clearTryReconnectTimeout();\n    var delay = this.backoff.duration();\n    this.tryReconnectTimeoutId = setTimeout(function () {\n      _this.connect();\n    }, delay);\n  };\n\n  SubscriptionClient.prototype.flushUnsentMessagesQueue = function () {\n    var _this = this;\n\n    this.unsentMessagesQueue.forEach(function (message) {\n      _this.sendMessageRaw(message);\n    });\n    this.unsentMessagesQueue = [];\n  };\n\n  SubscriptionClient.prototype.checkConnection = function () {\n    if (this.wasKeepAliveReceived) {\n      this.wasKeepAliveReceived = false;\n      return;\n    }\n\n    if (!this.reconnecting) {\n      this.close(false, true);\n    }\n  };\n\n  SubscriptionClient.prototype.checkMaxConnectTimeout = function () {\n    var _this = this;\n\n    this.clearMaxConnectTimeout();\n    this.maxConnectTimeoutId = setTimeout(function () {\n      if (_this.status !== _this.wsImpl.OPEN) {\n        _this.reconnecting = true;\n\n        _this.close(false, true);\n      }\n    }, this.maxConnectTimeGenerator.duration());\n  };\n\n  SubscriptionClient.prototype.connect = function () {\n    var _a;\n\n    var _this = this;\n\n    this.client = new ((_a = this.wsImpl).bind.apply(_a, __spreadArrays([void 0, this.url, this.wsProtocols], this.wsOptionArguments)))();\n    this.checkMaxConnectTimeout();\n\n    this.client.onopen = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var connectionParams, error_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!(this.status === this.wsImpl.OPEN)) return [3, 4];\n              this.clearMaxConnectTimeout();\n              this.closedByUser = false;\n              this.eventEmitter.emit(this.reconnecting ? 'reconnecting' : 'connecting');\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 3,, 4]);\n\n              return [4, this.connectionParams()];\n\n            case 2:\n              connectionParams = _a.sent();\n              this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_INIT, connectionParams);\n              this.flushUnsentMessagesQueue();\n              return [3, 4];\n\n            case 3:\n              error_1 = _a.sent();\n              this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_ERROR, error_1);\n              this.flushUnsentMessagesQueue();\n              return [3, 4];\n\n            case 4:\n              return [2];\n          }\n        });\n      });\n    };\n\n    this.client.onclose = function () {\n      if (!_this.closedByUser) {\n        _this.close(false, false);\n      }\n    };\n\n    this.client.onerror = function (err) {\n      _this.eventEmitter.emit('error', err);\n    };\n\n    this.client.onmessage = function (_a) {\n      var data = _a.data;\n\n      _this.processReceivedData(data);\n    };\n  };\n\n  SubscriptionClient.prototype.processReceivedData = function (receivedData) {\n    var parsedMessage;\n    var opId;\n\n    try {\n      parsedMessage = JSON.parse(receivedData);\n      opId = parsedMessage.id;\n    } catch (e) {\n      throw new Error(\"Message must be JSON-parseable. Got: \" + receivedData);\n    }\n\n    if ([message_types_1.default.GQL_DATA, message_types_1.default.GQL_COMPLETE, message_types_1.default.GQL_ERROR].indexOf(parsedMessage.type) !== -1 && !this.operations[opId]) {\n      this.unsubscribe(opId);\n      return;\n    }\n\n    switch (parsedMessage.type) {\n      case message_types_1.default.GQL_CONNECTION_ERROR:\n        if (this.connectionCallback) {\n          this.connectionCallback(parsedMessage.payload);\n        }\n\n        break;\n\n      case message_types_1.default.GQL_CONNECTION_ACK:\n        this.eventEmitter.emit(this.reconnecting ? 'reconnected' : 'connected', parsedMessage.payload);\n        this.reconnecting = false;\n        this.backoff.reset();\n        this.maxConnectTimeGenerator.reset();\n\n        if (this.connectionCallback) {\n          this.connectionCallback();\n        }\n\n        break;\n\n      case message_types_1.default.GQL_COMPLETE:\n        var handler = this.operations[opId].handler;\n        delete this.operations[opId];\n        handler.call(this, null, null);\n        break;\n\n      case message_types_1.default.GQL_ERROR:\n        this.operations[opId].handler(this.formatErrors(parsedMessage.payload), null);\n        delete this.operations[opId];\n        break;\n\n      case message_types_1.default.GQL_DATA:\n        var parsedPayload = !parsedMessage.payload.errors ? parsedMessage.payload : __assign(__assign({}, parsedMessage.payload), {\n          errors: this.formatErrors(parsedMessage.payload.errors)\n        });\n        this.operations[opId].handler(null, parsedPayload);\n        break;\n\n      case message_types_1.default.GQL_CONNECTION_KEEP_ALIVE:\n        var firstKA = typeof this.wasKeepAliveReceived === 'undefined';\n        this.wasKeepAliveReceived = true;\n\n        if (firstKA) {\n          this.checkConnection();\n        }\n\n        if (this.checkConnectionIntervalId) {\n          clearInterval(this.checkConnectionIntervalId);\n          this.checkConnection();\n        }\n\n        this.checkConnectionIntervalId = setInterval(this.checkConnection.bind(this), this.wsTimeout);\n        break;\n\n      default:\n        throw new Error('Invalid message type!');\n    }\n  };\n\n  SubscriptionClient.prototype.unsubscribe = function (opId) {\n    if (this.operations[opId]) {\n      delete this.operations[opId];\n      this.setInactivityTimeout();\n      this.sendMessage(opId, message_types_1.default.GQL_STOP, undefined);\n    }\n  };\n\n  return SubscriptionClient;\n}();\n\nexports.SubscriptionClient = SubscriptionClient;","map":{"version":3,"mappings":"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","names":["_global","global","window","NativeWebSocket","WebSocket","MozWebSocket","url","options","webSocketImpl","webSocketProtocols","_b","connectionCallback","undefined","_c","connectionParams","_d","minTimeout","defaults_1","_e","timeout","_f","reconnect","_g","reconnectionAttempts","Infinity","_h","lazy","_j","inactivityTimeout","_k","wsOptionArguments","wsImpl","Error","wsProtocols","protocol_1","operations","nextOperationId","minWsTimeout","wsTimeout","unsentMessagesQueue","reconnecting","closedByUser","backoff","Backoff","jitter","eventEmitter","eventemitter3_1","middlewares","client","maxConnectTimeGenerator","createMaxConnectTimeGenerator","getConnectionParams","connect","Object","SubscriptionClient","CLOSED","readyState","isForced","clearInactivityTimeout","clearCheckConnectionInterval","clearMaxConnectTimeout","clearTryReconnectTimeout","unsubscribeAll","sendMessage","message_types_1","GQL_CONNECTION_TERMINATE","close","onopen","onclose","onerror","onmessage","emit","tryReconnect","request","getObserver","bind","executeOperation","unsubscribe","opId","_a","symbol_observable_1","observerOrNext","onError","onComplete","observer","error","result","complete","next","eventName","callback","context","handler","on","off","keys","forEach","_this","subId","Promise","resolve","reject","queue","funcs","scope","length","f","shift","applyMiddleware","apply","map","middleware","push","call","generateOperationId","applyMiddlewares","then","checkOperationOptions","processedOptions","GQL_START","catch","formatErrors","v","e","minValue","maxValue","min","max","factor","checkConnectionIntervalId","clearInterval","maxConnectTimeoutId","clearTimeout","tryReconnectTimeoutId","inactivityTimeoutId","setTimeout","variables","operationName","query","is_string_1","getOperationAST_1","is_object_1","id","type","payload","payloadToReturn","__assign","printer_1","errors","Array","isArray","message","name","originalError","sendMessageRaw","buildMessage","status","OPEN","serializedMessage","JSON","stringify","parse","send","CONNECTING","String","attempts","key","delay","duration","wasKeepAliveReceived","__spreadArrays","checkMaxConnectTimeout","GQL_CONNECTION_INIT","flushUnsentMessagesQueue","GQL_CONNECTION_ERROR","error_1","err","data","processReceivedData","receivedData","parsedMessage","GQL_DATA","GQL_COMPLETE","GQL_ERROR","indexOf","GQL_CONNECTION_ACK","reset","parsedPayload","GQL_CONNECTION_KEEP_ALIVE","firstKA","checkConnection","setInterval","setInactivityTimeout","GQL_STOP","exports"],"sourceRoot":"","sources":["../src/client.ts"],"sourcesContent":["declare let window: any;\nconst _global = typeof global !== 'undefined' ? global : (typeof window !== 'undefined' ? window : {});\nconst NativeWebSocket = _global.WebSocket || _global.MozWebSocket;\n\nimport * as Backoff from 'backo2';\nimport { default as EventEmitterType, EventEmitter, ListenerFn } from 'eventemitter3';\nimport isString from './utils/is-string';\nimport isObject from './utils/is-object';\nimport { ExecutionResult } from 'graphql/execution/execute';\nimport { print } from 'graphql/language/printer';\nimport { DocumentNode } from 'graphql/language/ast';\nimport { getOperationAST } from 'graphql/utilities/getOperationAST';\nimport $$observable from 'symbol-observable';\n\nimport { GRAPHQL_WS } from './protocol';\nimport { MIN_WS_TIMEOUT, WS_TIMEOUT } from './defaults';\nimport MessageTypes from './message-types';\n\nexport interface Observer<T> {\n  next?: (value: T) => void;\n  error?: (error: Error) => void;\n  complete?: () => void;\n}\n\nexport interface Observable<T> {\n  subscribe(observer: Observer<T>): {\n    unsubscribe: () => void;\n  };\n}\n\nexport interface OperationOptions {\n  query?: string | DocumentNode;\n  variables?: Object;\n  operationName?: string;\n  [key: string]: any;\n}\n\nexport type FormatedError = Error & {\n  originalError?: any;\n};\n\nexport interface Operation {\n  options: OperationOptions;\n  handler: (error: Error[], result?: any) => void;\n}\n\nexport interface Operations {\n  [id: string]: Operation;\n}\n\nexport interface Middleware {\n  applyMiddleware(options: OperationOptions, next: Function): void;\n}\n\nexport type ConnectionParams = {\n  [paramName: string]: any,\n};\n\nexport type ConnectionParamsOptions = ConnectionParams | Function | Promise<ConnectionParams>;\n\nexport interface ClientOptions {\n  connectionParams?: ConnectionParamsOptions;\n  minTimeout?: number;\n  timeout?: number;\n  reconnect?: boolean;\n  reconnectionAttempts?: number;\n  connectionCallback?: (error: Error[], result?: any) => void;\n  lazy?: boolean;\n  inactivityTimeout?: number;\n  wsOptionArguments?: any[];\n}\n\nexport class SubscriptionClient {\n  public client: any;\n  public operations: Operations;\n  private url: string;\n  private nextOperationId: number;\n  private connectionParams: Function;\n  private minWsTimeout: number;\n  private wsTimeout: number;\n  private unsentMessagesQueue: Array<any>; // queued messages while websocket is opening.\n  private reconnect: boolean;\n  private reconnecting: boolean;\n  private reconnectionAttempts: number;\n  private backoff: any;\n  private connectionCallback: any;\n  private eventEmitter: EventEmitterType;\n  private lazy: boolean;\n  private inactivityTimeout: number;\n  private inactivityTimeoutId: any;\n  private closedByUser: boolean;\n  private wsImpl: any;\n  private wsProtocols: string | string[];\n  private wasKeepAliveReceived: boolean;\n  private tryReconnectTimeoutId: any;\n  private checkConnectionIntervalId: any;\n  private maxConnectTimeoutId: any;\n  private middlewares: Middleware[];\n  private maxConnectTimeGenerator: any;\n  private wsOptionArguments: any[];\n\n  constructor(\n    url: string,\n    options?: ClientOptions,\n    webSocketImpl?: any,\n    webSocketProtocols?: string | string[],\n  ) {\n    const {\n      connectionCallback = undefined,\n      connectionParams = {},\n      minTimeout = MIN_WS_TIMEOUT,\n      timeout = WS_TIMEOUT,\n      reconnect = false,\n      reconnectionAttempts = Infinity,\n      lazy = false,\n      inactivityTimeout = 0,\n      wsOptionArguments = [],\n    } = (options || {});\n\n    this.wsImpl = webSocketImpl || NativeWebSocket;\n    if (!this.wsImpl) {\n      throw new Error('Unable to find native implementation, or alternative implementation for WebSocket!');\n    }\n\n    this.wsProtocols = webSocketProtocols || GRAPHQL_WS;\n    this.connectionCallback = connectionCallback;\n    this.url = url;\n    this.operations = {};\n    this.nextOperationId = 0;\n    this.minWsTimeout = minTimeout;\n    this.wsTimeout = timeout;\n    this.unsentMessagesQueue = [];\n    this.reconnect = reconnect;\n    this.reconnecting = false;\n    this.reconnectionAttempts = reconnectionAttempts;\n    this.lazy = !!lazy;\n    this.inactivityTimeout = inactivityTimeout;\n    this.closedByUser = false;\n    this.backoff = new Backoff({ jitter: 0.5 });\n    this.eventEmitter = new EventEmitter();\n    this.middlewares = [];\n    this.client = null;\n    this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();\n    this.connectionParams = this.getConnectionParams(connectionParams);\n    this.wsOptionArguments = wsOptionArguments;\n\n    if (!this.lazy) {\n      this.connect();\n    }\n  }\n\n  public get status() {\n    if (this.client === null) {\n      return this.wsImpl.CLOSED;\n    }\n\n    return this.client.readyState;\n  }\n\n  public close(isForced = true, closedByUser = true) {\n    this.clearInactivityTimeout();\n    if (this.client !== null) {\n      this.closedByUser = closedByUser;\n\n      if (isForced) {\n        this.clearCheckConnectionInterval();\n        this.clearMaxConnectTimeout();\n        this.clearTryReconnectTimeout();\n        this.unsubscribeAll();\n        this.sendMessage(undefined, MessageTypes.GQL_CONNECTION_TERMINATE, null);\n      }\n\n      this.client.close();\n      this.client.onopen = null;\n      this.client.onclose = null;\n      this.client.onerror = null;\n      this.client.onmessage = null;\n      this.client = null;\n      this.eventEmitter.emit('disconnected');\n\n      if (!isForced) {\n        this.tryReconnect();\n      }\n    }\n  }\n\n  public request(request: OperationOptions): Observable<ExecutionResult> {\n    const getObserver = this.getObserver.bind(this);\n    const executeOperation = this.executeOperation.bind(this);\n    const unsubscribe = this.unsubscribe.bind(this);\n\n    let opId: string;\n\n    this.clearInactivityTimeout();\n\n    return {\n      [$$observable]() {\n        return this;\n      },\n      subscribe(\n        observerOrNext: ((Observer<ExecutionResult>) | ((v: ExecutionResult) => void)),\n        onError?: (error: Error) => void,\n        onComplete?: () => void,\n      ) {\n        const observer = getObserver(observerOrNext, onError, onComplete);\n\n        opId = executeOperation(request, (error: Error[], result: any) => {\n          if ( error === null && result === null ) {\n            if ( observer.complete ) {\n              observer.complete();\n            }\n          } else if (error) {\n            if ( observer.error ) {\n              observer.error(error[0]);\n            }\n          } else {\n            if ( observer.next ) {\n              observer.next(result);\n            }\n          }\n        });\n\n        return {\n          unsubscribe: () => {\n            if ( opId ) {\n              unsubscribe(opId);\n              opId = null;\n            }\n          },\n        };\n      },\n    };\n  }\n\n  public on(eventName: string, callback: ListenerFn, context?: any): Function {\n    const handler = this.eventEmitter.on(eventName, callback, context);\n\n    return () => {\n      handler.off(eventName, callback, context);\n    };\n  }\n\n  public onConnected(callback: ListenerFn, context?: any): Function {\n    return this.on('connected', callback, context);\n  }\n\n  public onConnecting(callback: ListenerFn, context?: any): Function {\n    return this.on('connecting', callback, context);\n  }\n\n  public onDisconnected(callback: ListenerFn, context?: any): Function {\n    return this.on('disconnected', callback, context);\n  }\n\n  public onReconnected(callback: ListenerFn, context?: any): Function {\n    return this.on('reconnected', callback, context);\n  }\n\n  public onReconnecting(callback: ListenerFn, context?: any): Function {\n    return this.on('reconnecting', callback, context);\n  }\n\n  public onError(callback: ListenerFn, context?: any): Function {\n    return this.on('error', callback, context);\n  }\n\n  public unsubscribeAll() {\n    Object.keys(this.operations).forEach( subId => {\n      this.unsubscribe(subId);\n    });\n  }\n\n  public applyMiddlewares(options: OperationOptions): Promise<OperationOptions> {\n    return new Promise((resolve, reject) => {\n      const queue = (funcs: Middleware[], scope: any) => {\n        const next = (error?: any) => {\n          if (error) {\n            reject(error);\n          } else {\n            if (funcs.length > 0) {\n              const f = funcs.shift();\n              if (f) {\n                f.applyMiddleware.apply(scope, [options, next]);\n              }\n            } else {\n              resolve(options);\n            }\n          }\n        };\n        next();\n      };\n\n      queue([...this.middlewares], this);\n    });\n  }\n\n  public use(middlewares: Middleware[]): SubscriptionClient {\n    middlewares.map((middleware) => {\n      if (typeof middleware.applyMiddleware === 'function') {\n        this.middlewares.push(middleware);\n      } else {\n        throw new Error('Middleware must implement the applyMiddleware function.');\n      }\n    });\n\n    return this;\n  }\n\n  private getConnectionParams(connectionParams: ConnectionParamsOptions): Function {\n    return (): Promise<ConnectionParams> => new Promise((resolve, reject) => {\n      if (typeof connectionParams === 'function') {\n        try {\n          return resolve(connectionParams.call(null));\n        } catch (error) {\n          return reject(error);\n        }\n      }\n\n      resolve(connectionParams);\n    });\n  }\n\n  private executeOperation(options: OperationOptions, handler: (error: Error[], result?: any) => void): string {\n    if (this.client === null) {\n      this.connect();\n    }\n\n    const opId = this.generateOperationId();\n    this.operations[opId] = { options: options, handler };\n\n    this.applyMiddlewares(options)\n      .then(processedOptions => {\n        this.checkOperationOptions(processedOptions, handler);\n        if (this.operations[opId]) {\n          this.operations[opId] = { options: processedOptions, handler };\n          this.sendMessage(opId, MessageTypes.GQL_START, processedOptions);\n        }\n      })\n      .catch(error => {\n        this.unsubscribe(opId);\n        handler(this.formatErrors(error));\n      });\n\n    return opId;\n  }\n\n  private getObserver<T>(\n    observerOrNext: ((Observer<T>) | ((v: T) => void)),\n    error?: (e: Error) => void,\n    complete?: () => void,\n  ) {\n    if ( typeof observerOrNext === 'function' ) {\n      return {\n        next: (v: T) => observerOrNext(v),\n        error: (e: Error) => error && error(e),\n        complete: () => complete && complete(),\n      };\n    }\n\n    return observerOrNext;\n  }\n\n  private createMaxConnectTimeGenerator() {\n    const minValue = this.minWsTimeout;\n    const maxValue = this.wsTimeout;\n\n    return new Backoff({\n      min: minValue,\n      max: maxValue,\n      factor: 1.2,\n    });\n  }\n\n  private clearCheckConnectionInterval() {\n    if (this.checkConnectionIntervalId) {\n      clearInterval(this.checkConnectionIntervalId);\n      this.checkConnectionIntervalId = null;\n    }\n  }\n\n  private clearMaxConnectTimeout() {\n    if (this.maxConnectTimeoutId) {\n      clearTimeout(this.maxConnectTimeoutId);\n      this.maxConnectTimeoutId = null;\n    }\n    }\n\n  private clearTryReconnectTimeout() {\n    if (this.tryReconnectTimeoutId) {\n      clearTimeout(this.tryReconnectTimeoutId);\n      this.tryReconnectTimeoutId = null;\n    }\n  }\n\n  private clearInactivityTimeout() {\n    if (this.inactivityTimeoutId) {\n      clearTimeout(this.inactivityTimeoutId);\n      this.inactivityTimeoutId = null;\n    }\n  }\n\n  private setInactivityTimeout() {\n    if (this.inactivityTimeout > 0 && Object.keys(this.operations).length === 0) {\n      this.inactivityTimeoutId = setTimeout(() => {\n        if (Object.keys(this.operations).length === 0) {\n          this.close();\n        }\n      }, this.inactivityTimeout);\n    }\n  }\n\n  private checkOperationOptions(options: OperationOptions, handler: (error: Error[], result?: any) => void) {\n    const { query, variables, operationName } = options;\n\n    if (!query) {\n      throw new Error('Must provide a query.');\n    }\n\n    if (!handler) {\n      throw new Error('Must provide an handler.');\n    }\n\n    if (\n      ( !isString(query) && !getOperationAST(query, operationName)) ||\n      ( operationName && !isString(operationName)) ||\n      ( variables && !isObject(variables))\n    ) {\n      throw new Error('Incorrect option types. query must be a string or a document,' +\n        '`operationName` must be a string, and `variables` must be an object.');\n    }\n  }\n\n  private buildMessage(id: string, type: string, payload: any) {\n    const payloadToReturn = payload && payload.query ?\n      {\n        ...payload,\n        query: typeof payload.query === 'string' ? payload.query : print(payload.query),\n      } :\n      payload;\n\n    return {\n      id,\n      type,\n      payload: payloadToReturn,\n    };\n  }\n\n  // ensure we have an array of errors\n  private formatErrors(errors: any): FormatedError[] {\n    if (Array.isArray(errors)) {\n      return errors;\n    }\n\n    // TODO  we should not pass ValidationError to callback in the future.\n    // ValidationError\n    if (errors && errors.errors) {\n      return this.formatErrors(errors.errors);\n    }\n\n    if (errors && errors.message) {\n      return [errors];\n    }\n\n    return [{\n      name: 'FormatedError',\n      message: 'Unknown error',\n      originalError: errors,\n    }];\n  }\n\n  private sendMessage(id: string, type: string, payload: any) {\n    this.sendMessageRaw(this.buildMessage(id, type, payload));\n  }\n\n  // send message, or queue it if connection is not open\n  private sendMessageRaw(message: Object) {\n    switch (this.status) {\n      case this.wsImpl.OPEN:\n        let serializedMessage: string = JSON.stringify(message);\n        try {\n          JSON.parse(serializedMessage);\n        } catch (e) {\n          this.eventEmitter.emit('error', new Error(`Message must be JSON-serializable. Got: ${message}`));\n        }\n\n        this.client.send(serializedMessage);\n        break;\n      case this.wsImpl.CONNECTING:\n        this.unsentMessagesQueue.push(message);\n\n        break;\n      default:\n        if (!this.reconnecting) {\n          this.eventEmitter.emit('error', new Error('A message was not sent because socket is not connected, is closing or ' +\n            'is already closed. Message was: ' + JSON.stringify(message)));\n        }\n    }\n  }\n\n  private generateOperationId(): string {\n    return String(++this.nextOperationId);\n  }\n\n  private tryReconnect() {\n    if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {\n      return;\n    }\n\n    if (!this.reconnecting) {\n      Object.keys(this.operations).forEach((key) => {\n        this.unsentMessagesQueue.push(\n          this.buildMessage(key, MessageTypes.GQL_START, this.operations[key].options),\n        );\n      });\n      this.reconnecting = true;\n    }\n\n    this.clearTryReconnectTimeout();\n\n    const delay = this.backoff.duration();\n    this.tryReconnectTimeoutId = setTimeout(() => {\n      this.connect();\n    }, delay);\n  }\n\n  private flushUnsentMessagesQueue() {\n    this.unsentMessagesQueue.forEach((message) => {\n      this.sendMessageRaw(message);\n    });\n    this.unsentMessagesQueue = [];\n  }\n\n  private checkConnection() {\n    if (this.wasKeepAliveReceived) {\n      this.wasKeepAliveReceived = false;\n      return;\n    }\n\n    if (!this.reconnecting) {\n      this.close(false, true);\n    }\n  }\n\n  private checkMaxConnectTimeout() {\n    this.clearMaxConnectTimeout();\n\n    // Max timeout trying to connect\n    this.maxConnectTimeoutId = setTimeout(() => {\n      if (this.status !== this.wsImpl.OPEN) {\n        this.reconnecting = true;\n        this.close(false, true);\n      }\n    }, this.maxConnectTimeGenerator.duration());\n  }\n\n  private connect() {\n    this.client = new this.wsImpl(this.url, this.wsProtocols, ...this.wsOptionArguments);\n\n    this.checkMaxConnectTimeout();\n\n    this.client.onopen = async () => {\n      if (this.status === this.wsImpl.OPEN) {\n        this.clearMaxConnectTimeout();\n        this.closedByUser = false;\n        this.eventEmitter.emit(this.reconnecting ? 'reconnecting' : 'connecting');\n\n        try {\n          const connectionParams: ConnectionParams = await this.connectionParams();\n\n          // Send CONNECTION_INIT message, no need to wait for connection to success (reduce roundtrips)\n          this.sendMessage(undefined, MessageTypes.GQL_CONNECTION_INIT, connectionParams);\n          this.flushUnsentMessagesQueue();\n        } catch (error) {\n          this.sendMessage(undefined, MessageTypes.GQL_CONNECTION_ERROR, error);\n          this.flushUnsentMessagesQueue();\n        }\n      }\n    };\n\n    this.client.onclose = () => {\n      if (!this.closedByUser) {\n        this.close(false, false);\n      }\n    };\n\n    this.client.onerror = (err: Error) => {\n      // Capture and ignore errors to prevent unhandled exceptions, wait for\n      // onclose to fire before attempting a reconnect.\n      this.eventEmitter.emit('error', err);\n    };\n\n    this.client.onmessage = ({ data }: {data: any}) => {\n      this.processReceivedData(data);\n    };\n  }\n\n  private processReceivedData(receivedData: any) {\n    let parsedMessage: any;\n    let opId: string;\n\n    try {\n      parsedMessage = JSON.parse(receivedData);\n      opId = parsedMessage.id;\n    } catch (e) {\n      throw new Error(`Message must be JSON-parseable. Got: ${receivedData}`);\n    }\n\n    if (\n      [ MessageTypes.GQL_DATA,\n        MessageTypes.GQL_COMPLETE,\n        MessageTypes.GQL_ERROR,\n      ].indexOf(parsedMessage.type) !== -1 && !this.operations[opId]\n    ) {\n      this.unsubscribe(opId);\n\n      return;\n    }\n\n    switch (parsedMessage.type) {\n      case MessageTypes.GQL_CONNECTION_ERROR:\n        if (this.connectionCallback) {\n          this.connectionCallback(parsedMessage.payload);\n        }\n        break;\n\n      case MessageTypes.GQL_CONNECTION_ACK:\n        this.eventEmitter.emit(this.reconnecting ? 'reconnected' : 'connected', parsedMessage.payload);\n        this.reconnecting = false;\n        this.backoff.reset();\n        this.maxConnectTimeGenerator.reset();\n\n        if (this.connectionCallback) {\n          this.connectionCallback();\n        }\n        break;\n\n      case MessageTypes.GQL_COMPLETE:\n        const handler = this.operations[opId].handler;\n        delete this.operations[opId];\n        handler.call(this, null, null);\n        break;\n\n      case MessageTypes.GQL_ERROR:\n        this.operations[opId].handler(this.formatErrors(parsedMessage.payload), null);\n        delete this.operations[opId];\n        break;\n\n      case MessageTypes.GQL_DATA:\n        const parsedPayload = !parsedMessage.payload.errors ?\n          parsedMessage.payload : {...parsedMessage.payload, errors: this.formatErrors(parsedMessage.payload.errors)};\n        this.operations[opId].handler(null, parsedPayload);\n        break;\n\n      case MessageTypes.GQL_CONNECTION_KEEP_ALIVE:\n        const firstKA = typeof this.wasKeepAliveReceived === 'undefined';\n        this.wasKeepAliveReceived = true;\n\n        if (firstKA) {\n          this.checkConnection();\n        }\n\n        if (this.checkConnectionIntervalId) {\n          clearInterval(this.checkConnectionIntervalId);\n          this.checkConnection();\n        }\n        this.checkConnectionIntervalId = setInterval(this.checkConnection.bind(this), this.wsTimeout);\n        break;\n\n      default:\n        throw new Error('Invalid message type!');\n    }\n  }\n\n  private unsubscribe(opId: string) {\n    if (this.operations[opId]) {\n      delete this.operations[opId];\n      this.setInactivityTimeout();\n      this.sendMessage(opId, MessageTypes.GQL_STOP, undefined);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}